// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ObservationLidar2D.proto

#ifndef PROTOBUF_INCLUDED_ObservationLidar2D_2eproto
#define PROTOBUF_INCLUDED_ObservationLidar2D_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Pose.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ObservationLidar2D_2eproto 

namespace protobuf_ObservationLidar2D_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ObservationLidar2D_2eproto
namespace mvsim_msgs {
class ObservationLidar2D;
class ObservationLidar2DDefaultTypeInternal;
extern ObservationLidar2DDefaultTypeInternal _ObservationLidar2D_default_instance_;
}  // namespace mvsim_msgs
namespace google {
namespace protobuf {
template<> ::mvsim_msgs::ObservationLidar2D* Arena::CreateMaybeMessage<::mvsim_msgs::ObservationLidar2D>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mvsim_msgs {

// ===================================================================

class ObservationLidar2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mvsim_msgs.ObservationLidar2D) */ {
 public:
  ObservationLidar2D();
  virtual ~ObservationLidar2D();

  ObservationLidar2D(const ObservationLidar2D& from);

  inline ObservationLidar2D& operator=(const ObservationLidar2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObservationLidar2D(ObservationLidar2D&& from) noexcept
    : ObservationLidar2D() {
    *this = ::std::move(from);
  }

  inline ObservationLidar2D& operator=(ObservationLidar2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationLidar2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObservationLidar2D* internal_default_instance() {
    return reinterpret_cast<const ObservationLidar2D*>(
               &_ObservationLidar2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ObservationLidar2D* other);
  friend void swap(ObservationLidar2D& a, ObservationLidar2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObservationLidar2D* New() const final {
    return CreateMaybeMessage<ObservationLidar2D>(NULL);
  }

  ObservationLidar2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObservationLidar2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObservationLidar2D& from);
  void MergeFrom(const ObservationLidar2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationLidar2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float scanRanges = 3;
  int scanranges_size() const;
  void clear_scanranges();
  static const int kScanRangesFieldNumber = 3;
  float scanranges(int index) const;
  void set_scanranges(int index, float value);
  void add_scanranges(float value);
  const ::google::protobuf::RepeatedField< float >&
      scanranges() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_scanranges();

  // repeated bool validRanges = 4;
  int validranges_size() const;
  void clear_validranges();
  static const int kValidRangesFieldNumber = 4;
  bool validranges(int index) const;
  void set_validranges(int index, bool value);
  void add_validranges(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      validranges() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_validranges();

  // required string sourceObjectId = 2;
  bool has_sourceobjectid() const;
  void clear_sourceobjectid();
  static const int kSourceObjectIdFieldNumber = 2;
  const ::std::string& sourceobjectid() const;
  void set_sourceobjectid(const ::std::string& value);
  #if LANG_CXX11
  void set_sourceobjectid(::std::string&& value);
  #endif
  void set_sourceobjectid(const char* value);
  void set_sourceobjectid(const char* value, size_t size);
  ::std::string* mutable_sourceobjectid();
  ::std::string* release_sourceobjectid();
  void set_allocated_sourceobjectid(::std::string* sourceobjectid);

  // required .mvsim_msgs.Pose sensorPose = 8;
  bool has_sensorpose() const;
  void clear_sensorpose();
  static const int kSensorPoseFieldNumber = 8;
  private:
  const ::mvsim_msgs::Pose& _internal_sensorpose() const;
  public:
  const ::mvsim_msgs::Pose& sensorpose() const;
  ::mvsim_msgs::Pose* release_sensorpose();
  ::mvsim_msgs::Pose* mutable_sensorpose();
  void set_allocated_sensorpose(::mvsim_msgs::Pose* sensorpose);

  // required double unixTimestamp = 1;
  bool has_unixtimestamp() const;
  void clear_unixtimestamp();
  static const int kUnixTimestampFieldNumber = 1;
  double unixtimestamp() const;
  void set_unixtimestamp(double value);

  // required float aperture = 5;
  bool has_aperture() const;
  void clear_aperture();
  static const int kApertureFieldNumber = 5;
  float aperture() const;
  void set_aperture(float value);

  // required bool ccw = 6;
  bool has_ccw() const;
  void clear_ccw();
  static const int kCcwFieldNumber = 6;
  bool ccw() const;
  void set_ccw(bool value);

  // required float maxRange = 7;
  bool has_maxrange() const;
  void clear_maxrange();
  static const int kMaxRangeFieldNumber = 7;
  float maxrange() const;
  void set_maxrange(float value);

  // @@protoc_insertion_point(class_scope:mvsim_msgs.ObservationLidar2D)
 private:
  void set_has_unixtimestamp();
  void clear_has_unixtimestamp();
  void set_has_sourceobjectid();
  void clear_has_sourceobjectid();
  void set_has_aperture();
  void clear_has_aperture();
  void set_has_ccw();
  void clear_has_ccw();
  void set_has_maxrange();
  void clear_has_maxrange();
  void set_has_sensorpose();
  void clear_has_sensorpose();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > scanranges_;
  ::google::protobuf::RepeatedField< bool > validranges_;
  ::google::protobuf::internal::ArenaStringPtr sourceobjectid_;
  ::mvsim_msgs::Pose* sensorpose_;
  double unixtimestamp_;
  float aperture_;
  bool ccw_;
  float maxrange_;
  friend struct ::protobuf_ObservationLidar2D_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObservationLidar2D

// required double unixTimestamp = 1;
inline bool ObservationLidar2D::has_unixtimestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObservationLidar2D::set_has_unixtimestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObservationLidar2D::clear_has_unixtimestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObservationLidar2D::clear_unixtimestamp() {
  unixtimestamp_ = 0;
  clear_has_unixtimestamp();
}
inline double ObservationLidar2D::unixtimestamp() const {
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.unixTimestamp)
  return unixtimestamp_;
}
inline void ObservationLidar2D::set_unixtimestamp(double value) {
  set_has_unixtimestamp();
  unixtimestamp_ = value;
  // @@protoc_insertion_point(field_set:mvsim_msgs.ObservationLidar2D.unixTimestamp)
}

// required string sourceObjectId = 2;
inline bool ObservationLidar2D::has_sourceobjectid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservationLidar2D::set_has_sourceobjectid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservationLidar2D::clear_has_sourceobjectid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservationLidar2D::clear_sourceobjectid() {
  sourceobjectid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sourceobjectid();
}
inline const ::std::string& ObservationLidar2D::sourceobjectid() const {
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.sourceObjectId)
  return sourceobjectid_.GetNoArena();
}
inline void ObservationLidar2D::set_sourceobjectid(const ::std::string& value) {
  set_has_sourceobjectid();
  sourceobjectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mvsim_msgs.ObservationLidar2D.sourceObjectId)
}
#if LANG_CXX11
inline void ObservationLidar2D::set_sourceobjectid(::std::string&& value) {
  set_has_sourceobjectid();
  sourceobjectid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mvsim_msgs.ObservationLidar2D.sourceObjectId)
}
#endif
inline void ObservationLidar2D::set_sourceobjectid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sourceobjectid();
  sourceobjectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mvsim_msgs.ObservationLidar2D.sourceObjectId)
}
inline void ObservationLidar2D::set_sourceobjectid(const char* value, size_t size) {
  set_has_sourceobjectid();
  sourceobjectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mvsim_msgs.ObservationLidar2D.sourceObjectId)
}
inline ::std::string* ObservationLidar2D::mutable_sourceobjectid() {
  set_has_sourceobjectid();
  // @@protoc_insertion_point(field_mutable:mvsim_msgs.ObservationLidar2D.sourceObjectId)
  return sourceobjectid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObservationLidar2D::release_sourceobjectid() {
  // @@protoc_insertion_point(field_release:mvsim_msgs.ObservationLidar2D.sourceObjectId)
  if (!has_sourceobjectid()) {
    return NULL;
  }
  clear_has_sourceobjectid();
  return sourceobjectid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservationLidar2D::set_allocated_sourceobjectid(::std::string* sourceobjectid) {
  if (sourceobjectid != NULL) {
    set_has_sourceobjectid();
  } else {
    clear_has_sourceobjectid();
  }
  sourceobjectid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourceobjectid);
  // @@protoc_insertion_point(field_set_allocated:mvsim_msgs.ObservationLidar2D.sourceObjectId)
}

// repeated float scanRanges = 3;
inline int ObservationLidar2D::scanranges_size() const {
  return scanranges_.size();
}
inline void ObservationLidar2D::clear_scanranges() {
  scanranges_.Clear();
}
inline float ObservationLidar2D::scanranges(int index) const {
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.scanRanges)
  return scanranges_.Get(index);
}
inline void ObservationLidar2D::set_scanranges(int index, float value) {
  scanranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:mvsim_msgs.ObservationLidar2D.scanRanges)
}
inline void ObservationLidar2D::add_scanranges(float value) {
  scanranges_.Add(value);
  // @@protoc_insertion_point(field_add:mvsim_msgs.ObservationLidar2D.scanRanges)
}
inline const ::google::protobuf::RepeatedField< float >&
ObservationLidar2D::scanranges() const {
  // @@protoc_insertion_point(field_list:mvsim_msgs.ObservationLidar2D.scanRanges)
  return scanranges_;
}
inline ::google::protobuf::RepeatedField< float >*
ObservationLidar2D::mutable_scanranges() {
  // @@protoc_insertion_point(field_mutable_list:mvsim_msgs.ObservationLidar2D.scanRanges)
  return &scanranges_;
}

// repeated bool validRanges = 4;
inline int ObservationLidar2D::validranges_size() const {
  return validranges_.size();
}
inline void ObservationLidar2D::clear_validranges() {
  validranges_.Clear();
}
inline bool ObservationLidar2D::validranges(int index) const {
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.validRanges)
  return validranges_.Get(index);
}
inline void ObservationLidar2D::set_validranges(int index, bool value) {
  validranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:mvsim_msgs.ObservationLidar2D.validRanges)
}
inline void ObservationLidar2D::add_validranges(bool value) {
  validranges_.Add(value);
  // @@protoc_insertion_point(field_add:mvsim_msgs.ObservationLidar2D.validRanges)
}
inline const ::google::protobuf::RepeatedField< bool >&
ObservationLidar2D::validranges() const {
  // @@protoc_insertion_point(field_list:mvsim_msgs.ObservationLidar2D.validRanges)
  return validranges_;
}
inline ::google::protobuf::RepeatedField< bool >*
ObservationLidar2D::mutable_validranges() {
  // @@protoc_insertion_point(field_mutable_list:mvsim_msgs.ObservationLidar2D.validRanges)
  return &validranges_;
}

// required float aperture = 5;
inline bool ObservationLidar2D::has_aperture() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObservationLidar2D::set_has_aperture() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObservationLidar2D::clear_has_aperture() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObservationLidar2D::clear_aperture() {
  aperture_ = 0;
  clear_has_aperture();
}
inline float ObservationLidar2D::aperture() const {
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.aperture)
  return aperture_;
}
inline void ObservationLidar2D::set_aperture(float value) {
  set_has_aperture();
  aperture_ = value;
  // @@protoc_insertion_point(field_set:mvsim_msgs.ObservationLidar2D.aperture)
}

// required bool ccw = 6;
inline bool ObservationLidar2D::has_ccw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObservationLidar2D::set_has_ccw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObservationLidar2D::clear_has_ccw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObservationLidar2D::clear_ccw() {
  ccw_ = false;
  clear_has_ccw();
}
inline bool ObservationLidar2D::ccw() const {
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.ccw)
  return ccw_;
}
inline void ObservationLidar2D::set_ccw(bool value) {
  set_has_ccw();
  ccw_ = value;
  // @@protoc_insertion_point(field_set:mvsim_msgs.ObservationLidar2D.ccw)
}

// required float maxRange = 7;
inline bool ObservationLidar2D::has_maxrange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObservationLidar2D::set_has_maxrange() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObservationLidar2D::clear_has_maxrange() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObservationLidar2D::clear_maxrange() {
  maxrange_ = 0;
  clear_has_maxrange();
}
inline float ObservationLidar2D::maxrange() const {
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.maxRange)
  return maxrange_;
}
inline void ObservationLidar2D::set_maxrange(float value) {
  set_has_maxrange();
  maxrange_ = value;
  // @@protoc_insertion_point(field_set:mvsim_msgs.ObservationLidar2D.maxRange)
}

// required .mvsim_msgs.Pose sensorPose = 8;
inline bool ObservationLidar2D::has_sensorpose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservationLidar2D::set_has_sensorpose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservationLidar2D::clear_has_sensorpose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mvsim_msgs::Pose& ObservationLidar2D::_internal_sensorpose() const {
  return *sensorpose_;
}
inline const ::mvsim_msgs::Pose& ObservationLidar2D::sensorpose() const {
  const ::mvsim_msgs::Pose* p = sensorpose_;
  // @@protoc_insertion_point(field_get:mvsim_msgs.ObservationLidar2D.sensorPose)
  return p != NULL ? *p : *reinterpret_cast<const ::mvsim_msgs::Pose*>(
      &::mvsim_msgs::_Pose_default_instance_);
}
inline ::mvsim_msgs::Pose* ObservationLidar2D::release_sensorpose() {
  // @@protoc_insertion_point(field_release:mvsim_msgs.ObservationLidar2D.sensorPose)
  clear_has_sensorpose();
  ::mvsim_msgs::Pose* temp = sensorpose_;
  sensorpose_ = NULL;
  return temp;
}
inline ::mvsim_msgs::Pose* ObservationLidar2D::mutable_sensorpose() {
  set_has_sensorpose();
  if (sensorpose_ == NULL) {
    auto* p = CreateMaybeMessage<::mvsim_msgs::Pose>(GetArenaNoVirtual());
    sensorpose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mvsim_msgs.ObservationLidar2D.sensorPose)
  return sensorpose_;
}
inline void ObservationLidar2D::set_allocated_sensorpose(::mvsim_msgs::Pose* sensorpose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sensorpose_);
  }
  if (sensorpose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensorpose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensorpose, submessage_arena);
    }
    set_has_sensorpose();
  } else {
    clear_has_sensorpose();
  }
  sensorpose_ = sensorpose;
  // @@protoc_insertion_point(field_set_allocated:mvsim_msgs.ObservationLidar2D.sensorPose)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace mvsim_msgs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ObservationLidar2D_2eproto
